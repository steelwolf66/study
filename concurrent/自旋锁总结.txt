自旋锁的理解

首先，自旋锁是基于重量级锁的基础上发生的。
jdk中，自旋锁是自适应的

举个例子
lock，是个锁对象，当被线程1占用时，会关联monitor，onwer是thread1

当线程2再去获取lock对象的时，会获取不到
正常是会进入阻塞状态，从而导致线程的上下文切换。所以jdk在这方面做了
优化，让Thread2循环获取lock对象（看monitor的owner是否为空），
而不是直接进入entryList,进入阻塞状态。当然，前提是有多余的CPU资源
可以供Thread2调用。然后这个循环的次数，是可配置的。假如Thread2 没有循环几次
就获取到了锁，jdk后续会多自旋几次，jdk7后默认开启