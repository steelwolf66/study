# JVM

## 1.JVM

### 1.线程私有

- 本地方法栈（动态扩展会OOM）
- 虚拟机栈（递归会栈溢出；动态扩展会OOM）
- 程序计数器（唯一不会OOM的区域）

### 2.线程共享

- 堆

  分为年轻代（1）和老年代（2），默认比例1:2

  细分为

  1. Eden【年轻代】（8）

     空间不足时，发生Minior GC

  2. From Survivor【年轻代】（1）

     上次GC的幸存者，作为这次GC的被扫描者

  3. To Survivor【年轻代】（1）

     保留当前GC过程中的幸存者

  4. Old【老年代】（20）

- 方法区/永久代

  元空间（元数据）

  jdk1.8之前，叫永久代，主要存放Class和Mate信息，Class被加载时，放入永久代，和存放实例地址不同，GC不会对永久代清理，所以这也导致，随着加载的Class增多而爆满，最终OOM。

  1.8之后，移除了永久代，被元空间替代。

  元空间和永久代类似，但是最主要的区别是，元空间的不在虚拟机中，而是直接使用本地内存。因此元空间的大小，也被本地内存限制。类的元数据放入native memory中，字符串池和类的静态变量放入Java堆中。这样加载Class的大小就不会被MaxPermSize限制，而是取决于本地内存

## 2.垃圾回收

#### （1）如何确定是垃圾

1. 引用计数法
2. 可达性分析

#### （2）Minior GC【复制算法】

复制 -> 清空 -> 互换

1. 把Eden区和From Survivor区中的存活对象，复制到To Survivor区中，这个过程中，年龄加一，符合老年代年龄的（默认死14）。如果To Survivor区的空间不能满足，则直接将其放入老年代区
2. 清空Eden区和From Survivor区
3. To Survivor区 和 From Survivor区互换，存活对象作为下次GC被扫描对象

#### （3）Major GC【标记清除算法】

1. 老年代对象稳定，不会频繁发生MajorGC。一般在发生MajorGC之前，都会发生一次MinorGC，在晋升老年代的过程中，空间不足，导致的
2. MajorGC会先扫描所有老年代对象，标记出存活的对象，然后回收没有标记的对象。MajorGC回收时间比较长，因为要先扫描，再回收，而且，MajorGC会产生内存碎片。为了提升效率和内存损耗，一般会将内存碎片进行合并或者标记，方便下次使用。
3. MajorGC后仍然装不下，就会OOM

## 3.常见垃圾回收算法

1. 复制算法(Copying)

   将存活的对象复制到另外的一块内存区域

   缺点：内存需划分为大小相同的两块；已使用内存过多时，效率很慢

2. 标记清除算法(Mark Sweep)

   将存活对象标记，回收未标记对象内存

   缺点：内存碎片化严重

3. 标记整理算法 （Mark Compact）

   标记阶段和之前一样，打标，然后不是直接回收内存，而是将存活对象移动到内存一端，最后清楚边界外的对象

4. 分代收集算法

   目前大多数JVM采用的垃圾回收算法

   将对象分为老年代和新生代

   新生代应该是每次GC都有很多对象被回收  【复制算法】

   老年代（对象相对较稳定）应该是每次都有较少对象被回收 【标记整理算法】

## 4.Java引用类型4种

- 强引用

  一个对象赋给引用变量，就是强引用

- 软引用

  需要通过SoftReference 类实现；对于只有软引用的对象，内存充足，就不会被回收。不足时就会被回收。

  所以软引用一般在对内存敏感的应用中使用；

- 弱引用

  需要通过WeakReference 类来实现；

  比软引用的生命周期更短，对于只有弱引用的对象，只要进行一次GC，该对象的内存就会被回收；

- 虚引用

  需要通过PhantomReference来实现，不能单独使用，需要和引用队列联合使用；虚引用的主要作用是跟踪对象被垃圾回收的状态；

## 5.垃圾回收器

##### CMS （ConcurrentMarkSweep）

并发标记清除算法

这里有个概念是安全检查点，就是在这个点的线程，不会丢失线程引用

并发标记，但是同时存在STW，因为在标记GC Root时，不暂停用户线程，会导致GC不完全；

通过GC Root判断对象说是否可达时，是并发标记的

会有个预清理

然后会有个重新标记（因为在并发标记的过程中，可能出现了一些对象已经没有引用了，就重新标记准备将其回收），也还是会存在STW

之后就是并发清除

##### Serial 垃圾收集器

单线程、复制算法

工作期间会STW

##### ParNew （Serial的多线程版本）

器默认开启和 CPU 数目相同的线程数

-XX:ParallelGCThreads

##### G1 收集器

Garbage First

目前垃圾回收器最前沿成果，相比于CMS最主要的两个改进：

- 基于标记-整理算法，不会有内存碎片
- 可以非常精准的控制停顿时间，在不牺牲吞吐量的前提下，实现低停顿的垃圾回收

G1垃圾回收器是将内存划分为几个独立的区域，并跟踪这些区域的垃圾回收进度，维护一个优先级，优先回收优先级最高的区域。

划分区域和优先级，确保了G1在有限时间内，回收效率达到了最大。



