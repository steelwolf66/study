# 算法题目

## 一、链表

### 1.相交链表 leeCode 160

给出两个链表，长度，m,n;

判断是否有交点，没有则返回null，有则返回节点

解法：

1）暴力穷举：当有相同的指针指向同一块地址即有相交

时间复杂度O(m*n)

也可以引入hash表，存一份，遍历第二个链表时，查看是否有

时间复杂度O（m+n）

空间复杂度增加，因为引入了一个hash表

2）双指针

分别从链表头部开始遍历，存在长短问题,就每次遍历完当前链表，就去遍历另外一个链表，总会有相交的时候。

 3）获取两个链表长度

从较长的链表开始遍历

从短链表的头节点下标开始遍历

然后对比是否在某个节点存在相同指针

### 2.链表翻转 LeeCode206

声明一个preNode

将当前节点的指针指向前一个节点，第一个节点指向preNode节点

### 3.回文链表 LeeCode234

回文链表：顺序遍历和倒序遍历的结果是一样的

1->2->2>1 true

1->2 false

解法1：

复制到数组中，双指针，分别从头部和尾部遍历，要求每个节点数据都相同，知道指针相遇

这样的解法空间复杂度增加了n

解法2：

快慢指针，分别步数分别为1,2

这样快指针到达终点时（这个要根据奇数个节点数（null节点）和偶数个节点数（最后一个节点）相关）

慢指针正好指向整个链表的中间节点，翻转后续的链表，和之前的数据对比

### 4.链表中间节点 LeeCode876

1.遍历整个链表，获取长度，/2,根据奇偶获取下标，重新遍历

2.快慢指针，例如回文列表

### 5.链表的倒数K个节点

解法1：

遍历链表，存到hash表中；m长度的链表，倒数第k个值的位置为m-k+1，从hash表中获取即可

增加了空间复杂度

解法2：

快慢指针

快指针先移动k-1个位置，然后再和慢指针每次移动一步，快指针到null时，慢指针指向的就是倒数第K个节点

没有增加空间复杂度

## 二、栈和队列

栈：FILO 先进后出

队列：FIFO 先进先出 插入数据一端称为队尾，移出一端称为队头

### 1.用栈实现队列 LeeCode232

定义两个栈：输入栈和输出栈

push时放入输入栈，取数时，将输入栈取数放入输出栈，之后操作输出栈

### 2.字符串解码 LeeCode394

找到元组 数字[字符串]

元组又可以被用作其他字符串

利用栈的先进后出特性，拆分[],获取每个元组，并组成字符串，再压栈，之后重新出栈达到拼接字符串的效果

## 三、树

### 1.树的相关概念

树的度：树的某个节点拥有的最大子节点数

树的高度：层级或深度（包括根节点）

树的表达：

- #### 双亲表示法

  |  id  | data | parentId |
  | :--: | :--: | :------: |
  |  1   |  A   |    -1    |
  |  2   |  B   |    1     |
  |  3   |  C   |    2     |

  查询父节点方便；

  查询子节点需遍历整个表

- #### 孩子表示法

  - | data | degree |      child1       |     child2      |
    | :--: | :----: | :---------------: | :-------------: |
    |  A   |   2    |  子节点B引用地址  | 子节点C引用地址 |
    |  B   |   1    | 子节点D的引用地址 |                 |
    |  C   |   0    |                   |                 |
    |  D   |   0    |                   |                 |

  记录当前节点的度，并记录子节点指针域

  

  用链表来表示当前节点的子节点

  用数组来存储每个节点

  叶子节点没有子节点，也就没有链表

- #### 双亲孩子表示法

  在孩子表示法的基础上，增加一列来存储父节点

- #### 二叉树

  度为2的树
  
- #### 特殊二叉树

  ##### 斜树

  每个节点都只有一个节点，且倾斜方向一致；左右斜树；

  ##### 满二叉树

  所有的节点都有左子树和又子树；

  所有的叶子节点都在同一层上；

  也就是说，叶子必须存在最下面一层

  非叶子节点的度一定是2

  ##### 完全二叉树

  是在满二叉树的之下的一种特殊二叉树

  定义：将满二叉树编号，从左到右，从上到下，如果一个二叉树能够满足这个编号顺序，即可称之为完全二叉树

  特殊意义：用数组来表示比较方便

  推论1：位置为K的节点，左子节点2*k+1,右子节点 2(k+1)

  推论2：数组长度为N，则最后一个非叶子节点的位置为 (N/2)-1

  

### 2.树的遍历

- #### 中序遍历

  根左右

  两种实现方式：

  递归：

  使用栈：

- #### 前序遍历

  左根右

- #### 后序遍历

  左右根







